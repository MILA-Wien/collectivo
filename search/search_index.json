{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Collectivo Documentation","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Collectivo is an open-source membership platform for communities and collectives. Through modular extensions, it can be customized and extended for the needs of different organizations.</p> <p>The features of Collectivo include management of memberships, emails, payments, and shifts. Further functionalities can be added through the integration of external services as well as the development of custom extensions.</p> <p>This project is in an early stage of development. It is a collaboration of the Austrian cooperative MILA Mitmach-Supermarkt and the IT collective convive* - funded by the AK Wien Digifonds.</p> <p>If you are interested to use this software or contribute to development, please write to info@collectivo.io.</p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>This site contains the project documentation for Collectivo.</p> <ol> <li>Getting started - A quick tutorial on how to set up your own instance</li> <li>User guide - Step-by-step instructions on how to use Collectivo</li> <li>Development - All you need to know to contribute to the project</li> <li>Reference - Technical description of Collectivo's API</li> <li>Core extensions<ul> <li>Core - Manage users, permissions, and settings</li> <li>Keycloak - Enable authentication with keycloak</li> <li>Extensions - Register custom extensions</li> <li>Components - Register external services</li> <li>Menus - Manage menus and menu items</li> <li>Dashboard - Manage the starting page</li> </ul> </li> <li>Feature extensions<ul> <li>Profiles - Add a basic user profile</li> <li>Tags - Assign tags to users</li> <li>Emails - Manage campaigns and automations</li> <li>Memberships - Manage memberships and applications</li> <li>Payments - Manage payment methods, invoices, and subscriptions</li> <li>Shifts - Create and coordinate working shifts</li> </ul> </li> </ol>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"contact/","title":"Contact","text":"<p>Collectivo is maintained by the Austrian cooperative MILA Mitmach-Supermarkt and the IT collective convive*. It is funded by the AK Wien Digifonds.</p> <p>You can find more information about us on collectivo.io, mila.wien, and convive.io.</p> <p>To contact us, please write to info@collectivo.io.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#set-up-a-development-environment","title":"Set up a development environment","text":"<p>The following instructions will help you set up a local system for the development of Collectivo. This setup is not necessary for the development custom extensions (see backend extensions and frontend extensions).</p>"},{"location":"development/#backend","title":"Backend","text":"<p>Install the following requirements:</p> <ul> <li>Docker (Version &gt;= 20.10)</li> </ul> <p>Add the following line to your hosts file:</p> etc/hosts<pre><code>127.0.0.1 keycloak\n</code></pre> <p>In your project folder, clone the collectivo repository and start a local instance of collectivo:</p> <pre><code>git clone https://github.com/MILA-Wien/collectivo.git\ncd collectivo\ncp .env.example .env\ndocker compose up -d\n</code></pre> <p>You can now access the following pages in your browser:</p> <ul> <li>Frontend: <code>http://localhost:8001</code></li> <li>Backend: <code>http://localhost:8000</code></li> <li>Keycloak: <code>http://localhost:8080</code></li> <li>Documentation: <code>http://localhost:8003</code></li> <li>API documentation: <code>http://localhost:8000/api/docs</code></li> </ul> <p>Perform tests and linting:</p> <pre><code>docker compose run --rm collectivo sh -c \"python manage.py test &amp;&amp; flake8\"\n</code></pre>"},{"location":"development/#frontend-optional","title":"Frontend (optional)","text":"<p>In addition to the above, you can also set up a development environment for the frontend.</p> <p>Install the following requirements:</p> <ul> <li>Yarn</li> </ul> <p>In your project folder, clone the collectivo-ux repository and start a development server:</p> <pre><code>git clone https://github.com/MILA-Wien/collectivo-ux.git\ncd collectivo-ux\nyarn\nyarn dev\n</code></pre> <p>You can now access the frontend at <code>http://localhost:5173</code>.</p> <p>Perform end-to-end tests and linting:</p> <pre><code>yarn build:staging\nyarn test:e2e\nyarn lint\n</code></pre>"},{"location":"development/#example-users","title":"Example users","text":"<p>If <code>example_data</code> is <code>true</code> in collectivo.yml, the following users will be available:</p> <ul> <li><code>test_superuser@example.com</code></li> <li><code>test_member_01@example.com</code>, <code>test_member_02@example.com</code>,   <code>test_member_03@example.com</code></li> <li><code>test_user_not_verified@example.com</code></li> <li><code>test_user_not_member@example.com</code></li> </ul> <p>The password for all users is <code>Test123!</code>.</p>"},{"location":"development/#backend-extensions","title":"Backend extensions","text":"<p>Extensions can be added to the backend of Collectivo as Django applications. The extension code is added to the application through a Docker volume. An alternative to extensions is to use external services.</p>"},{"location":"development/#installation","title":"Installation","text":"<p>Start from a clone of the quickstart repository and create a copy of the extension template:</p> <pre><code>cd collectivo/extensions/\ncp -r extension_template my_extension\n</code></pre> <p>Adapt the name of the extension in the app configuration:</p> collectivo/extensions/my_extension/apps.py<pre><code>class ExtensionConfig(AppConfig):\n    name = \"extensions.my_extension\"\n</code></pre> <p>Adapt the URL patterns in the extension:</p> collectivo/extensions/my_extension/urls.py<pre><code>app_name = 'extensions.my_extension'\n\nrouter = DefaultRouter()\n\nurlpatterns = [\n    path('api/my_extension/', include(router.urls)),\n]\n</code></pre> <p>Add the name of the extension to <code>collectivo.yml</code>:</p> collectivo/collectivo.yml<pre><code>extensions:\n  - extensions.my_extension\n</code></pre>"},{"location":"development/#background-tasks","title":"Background tasks","text":"<p>Collectivo uses Celery to run background tasks. To define a new task, create a file <code>tasks.py</code> in your extension folder and add a function with the <code>@shared_task</code> decorator. To avoid naming conflicts, the name of the task should start with the name of your extension. For example:</p> my_extension/tasks.py<pre><code>from celery import shared_task\n\n@shared_task(name=\"my_extension_task\")\ndef my_extension_task():\n    print(\"my_extension_task has been called\")\n</code></pre> <p>To define periodic tasks, create a file <code>schedules.py</code> in your extension folder and add a dictionary named <code>schedules</code>. The content of this dictionary should follow the syntax of celery's <code>app.conf.beat_schedule</code>. For example:</p> my_extension/schedules.py<pre><code>schedules = {\n    # Execute my_extension_task every 10 seconds\n    \"my_extension_task-10sec\": {\"task\": \"my_extension_task\", \"schedule\": 10.0},\n}\n</code></pre>"},{"location":"development/#frontend-extensions","title":"Frontend extensions","text":"<p>Extensions can be added to the frontend of Collectivo as Vue components. The extension code is added to the application in the build stage of the Docker container. An alternative to extensions is to use external services.</p>"},{"location":"development/#installation_1","title":"Installation","text":"<p>Start from a clone of the quickstart repository and create a copy of the extension template:</p> <pre><code>cd collectivo-ux/extensions/\ncp -r extension_template my_extension\n</code></pre> <p>Add the name of the extension to <code>collectivo.json</code>:</p> collectivo-ux/collectivo.json<pre><code>{\n  \"extensions\": [\"my_extension\"]\n}\n</code></pre>"},{"location":"guide/","title":"User guide","text":"<p>Step-by-step instructions on how to use Collectivo.</p>"},{"location":"guide/#installation","title":"Installation","text":"<p>To install Collectivo, follow these steps:</p> <ul> <li> <p>Install Docker (Version &gt;= 20.10)</p> </li> <li> <p>Clone the collectivo quickstart repository and set up a fresh environment file.</p> <pre><code>git clone https://github.com/MILA-Wien/collectivo-quickstart .\ncp .env.example .env\n</code></pre> </li> </ul>"},{"location":"guide/#local-instance","title":"Local instance","text":"<p>To run a local instance of Collectivo, follow these steps:</p> <ul> <li>Follow the installation instructions.</li> <li> <p>Add the following line to your hosts file:</p> etc/hosts<pre><code>127.0.0.1 keycloak\n</code></pre> </li> <li> <p>Optional: Define a version of Collectivo in <code>collectivo/Dockerfile</code> and <code>collectivo-ux/Dockerfile-dev</code>.</p> </li> <li>Run <code>docker compose up -d</code> to start the server.</li> <li>Run <code>docker compose build --no-cache --pull</code> to build fresh images.</li> <li>You can now go to <code>127.0.0.1:8001</code> and log in to Collectivo as <code>test_superuser@example.com</code> with the pasword <code>Test123!</code>.</li> </ul>"},{"location":"guide/#configuration","title":"Configuration","text":"<p>To configure collectivo, follow these steps:</p> <ul> <li>Follow the installation instructions.</li> <li>Change the backend settings in <code>collectivo/collectivo.yml</code>.</li> <li>Change the frontend settings in <code>collectivo-ux/collectivo.json</code>.<ul> <li>Set a new favicon as <code>collectivo-ux/favicon.ico</code></li> </ul> </li> </ul>"},{"location":"guide/#deployment","title":"Deployment","text":"<p>To deploy collectivo, follow these steps:</p> <ul> <li>Follow the installation instructions.</li> <li>Create separate DNS entries to your server for backend, frontend, and keycloak.</li> <li>Define your server settings and secret vars in <code>.env</code>.</li> <li>Run <code>docker-compose -f ./docker-compose.prod.yml up -d keycloak</code> to start keycloak.</li> <li>Go to your keycloak URL and log in to the admin console. Then go to the realm <code>collectivo</code> - <code>Clients</code> - <code>collectivo</code> - <code>Credentials</code>, generate a new client secret and put it in your <code>.env</code> file as <code>COLLECTIVO_KEYCLOAK_CLIENT_SECRET</code>.</li> <li>Define a version of Collectivo in <code>collectivo/Dockerfile</code> and <code>collectivo-ux/Dockerfile</code>.</li> <li>Run <code>docker compose -f ./docker-compose.prod.yml build --no-cache --pull</code> to build fresh images.</li> <li>Run <code>docker compose -f ./docker-compose.prod.yml up -d</code> to start the server.</li> </ul>"},{"location":"quickstart/","title":"Getting started","text":"<p>This tutorial will show you how to quickly set up your own local instance of Collectivo.</p> <p>Install the following requirements:</p> <ul> <li>Docker (Version &gt;= 20.10)</li> </ul> <p>Add the following line to your hosts file:</p> etc/hosts<pre><code>127.0.0.1 keycloak\n</code></pre> <p>In your project folder, clone the collectivo quickstart repository and start a local instance:</p> <pre><code>git clone https://github.com/MILA-Wien/collectivo-quickstart .\ncp .env.example .env\ndocker compose up -d\n</code></pre> <p>You can now go to <code>http://localhost:5173</code> and log in to Collectivo as <code>test_superuser@example.com</code> with the pasword <code>Test123!</code>.</p> <p>For further instructions, please refer to the user guide.</p>"},{"location":"reference/","title":"Reference","text":"<p>This section provides a technical description of Collectivo's models and functions. Further references can be found in the section of each extension. When the <code>api_docs</code> setting is enabled, an automated API documentation of your own instance can be found under <code>&lt;your-backend-url&gt;/api/docs</code>.</p>"},{"location":"reference/#backend-settings","title":"Backend Settings","text":""},{"location":"reference/#core","title":"Core","text":"<p>Custom settings for Collectivo can be set in <code>collectivo.yml</code>.</p> <p>Environment variables can be used with the <code>${ENV_VAR_NAME}</code> syntax.</p> <p>The following settings can be set:</p> <code>db_name</code> (string) <p>Name of the database.</p> <code>db_host</code> (string) <p>Hostname of the database.</p> <code>db_user</code> (string) <p>Username of the database.</p> <code>db_pass</code> (string) <p>Password of the database.</p> <code>secret_key</code> (string) <p>Secret key for the Django app.</p> <code>allowed_hosts</code> (list) <p>List of allowed hostnames of collectivo.</p> <code>allowed_origins</code> (list) <p>List of allowed URLs that can send requests to collectivo.</p> <code>extensions</code> (list) <p>Extensions that should be installed (list).</p> <p>Extensions can be added from three sources:</p> <ul> <li>Built-in modules of collectivo</li> <li>Modules placed in the ./extensions directory</li> <li>Packages installed via requirements.txt</li> </ul> <code>development</code> (boolean) <p>Activate development tools and debugging messages. Warning: Do not activate this setting on a production system, not even temporarily. It is possible to extract secrets from the system if this setting is active.</p> <code>example_data</code> (boolean) <p>Populate the instance with example data.</p> <code>api_docs</code> (boolean) <p>Activate Swagger UI under <code>/api/docs</code></p> <code>admin_user</code> (string) <p>Username of the admin user. Must be a valid email address.</p> <code>admin_pass</code> (string) <p>Password of the admin user.</p>"},{"location":"reference/#extensions","title":"Extensions","text":"<p>Each extension can have a file <code>extensions.yml</code> in its root folder, that will be used as default configuration variables for that extension.</p> <p>The following standard extension settings can be used:</p> <code>authentication_classes</code> (list) <p>Default authentication classes to be added to the Django REST framework.</p> <code>user_admin_serializer</code> (str) <p>A serializer class whose fields will be added to the <code>core/users</code> view.</p>"},{"location":"reference/#frontend-settings","title":"Frontend Settings","text":""},{"location":"reference/#core_1","title":"Core","text":"<p>Custom settings for the Collectivo frontend can be set in <code>src/collectivo.json</code>. A new build is necessary for these settings to be applied.</p> <p>The following settings can be set:</p> <code>extensions</code> (list) <p>Name of extensions to be included. The name must match the name of the extension folder in <code>src/extensions</code>. If the extension folder contains a file <code>extension.ts</code> with a default export function, this function will automatically be called before the app is started.</p>"},{"location":"reference/#extensions_1","title":"Extensions","text":"<p>Each frontend extension can have a file <code>extensions.json</code> in its root folder, that will be used as default configuration variables for that extension.</p> <p>The following standard extension settings can be used:</p> <code>endpoints</code> (dict) <p>Name and path of endpoints to be added to the API and main store.</p> <code>profile_admin_endpoints</code> (list) <p>Names of endpoints that should be used for the <code>/core/users/:id</code> view.</p> <code>profile_user_endpoints</code> (list) <p>Names of endpoints that should be used for the <code>/core/profile</code> view.</p>"},{"location":"extensions/components/","title":"Components","text":"<p>Define external components that can be used in the frontend. An alternative is to add Vue components directly to the frontend code through a custom extension.</p>"},{"location":"extensions/components/#installation","title":"Installation","text":"<p>Add <code>collectivo.components</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/components/#usage-by-other-extensions","title":"Usage by other extensions","text":""},{"location":"extensions/components/#register-a-component","title":"Register a component","text":"<p>A component can be registered by a custom extension as follows:</p> <pre><code>from collectivo.extensions.modles import Extension\nfrom collectivo.components.models import Component\n\nComponent.objects.register(\n    name='my-component',\n    type='iframe',\n    path='https://example.com',\n    extension=Extension.objects.get(name='my-extension'),\n)\n</code></pre> <p>There are two types of components:</p> <ul> <li><code>iframe</code>: The component is displayed as an iframe.</li> <li><code>remote</code>: The component is displayed as a remote webcomponent, using vite-plugin-federation. All Javascript frameworks that are supported by Vite can be used, including Vue, React, Svelte, and more. The path must point towards a remote entry point. This is an experimental feature and can be subject to errors.</li> </ul> <p>The component will be available on the frontend through the route <code>/&lt;extension.name&gt;/&lt;component.name&gt;</code>. For example, the component registered above will be available at <code>/my-extension/my-component</code> and will display an iframe to <code>https://example.com</code>.</p> <p>A menu item or dashboard button can be used to create an internal link to this route.</p>"},{"location":"extensions/components/#reference","title":"Reference","text":""},{"location":"extensions/components/#collectivo.components.models.Component","title":"<code>Component</code>","text":"<p>A frontend component.</p> Source code in <code>collectivo/components/models.py</code> <pre><code>class Component(models.Model):\n    \"\"\"A frontend component.\"\"\"\n\n    objects = NameManager()\n    name = models.CharField(\n        max_length=255, unique=True, help_text=\"Unique name of the component.\"\n    )\n    description = models.TextField(\n        blank=True, help_text=\"Description of the component and its features.\"\n    )\n    type = models.CharField(\n        max_length=255,\n        help_text=\"Type of the component.\",\n        choices=(\n            (\"remote\", \"Remote Entry\"),\n            (\"iframe\", \"Iframe\"),\n        ),\n    )\n    path = models.URLField(\n        blank=True,\n        help_text=\"URL of the remote entry point or iframe link.\",\n    )\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.CASCADE,\n        related_name=\"ux_components\",\n        null=True,\n        blank=True,\n        help_text=EXTENSION_HELP_TEXT,\n    )\n</code></pre>"},{"location":"extensions/core/","title":"Core","text":"<p>Manage users, permissions, and core settings. This extension is required for Collectivo to function.</p>"},{"location":"extensions/core/#installation","title":"Installation","text":"<p>Add <code>collectivo.core</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/core/#usage","title":"Usage","text":""},{"location":"extensions/core/#edit-profiles","title":"Edit profiles","text":"<p>Users can edit their profiles in the section <code>Profile</code>. This section displays the registered profile models of all extensions.</p>"},{"location":"extensions/core/#manage-user-profiles","title":"Manage user profiles","text":"<p>User data can be managed in the section <code>Users - Users</code>. This section displays the registered profile models of all extensions.</p>"},{"location":"extensions/core/#assign-permissions-to-users","title":"Assign permissions to users","text":"<p>Permission can be managed in the section <code>Users - Groups</code>. Permissions are assigned through permission groups. To assign a permission to a user, first add this permission to a permission group, and then add the user to this group.</p>"},{"location":"extensions/core/#reference","title":"Reference","text":""},{"location":"extensions/core/#collectivo.core.models.Permission","title":"<code>Permission</code>","text":"<p>A permission that can be assigned to a group.</p> Source code in <code>collectivo/core/models.py</code> <pre><code>class Permission(models.Model):\n    \"\"\"A permission that can be assigned to a group.\"\"\"\n\n    name = models.CharField(max_length=255)\n    label = models.CharField(max_length=255, blank=True)\n    description = models.TextField(blank=True)\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.CASCADE,\n        related_name=\"permissions\",\n        null=True,\n        blank=True,\n        help_text=EXTENSION_HELP_TEXT,\n    )\n\n    history = HistoricalRecords()\n    objects = NameManager()\n\n    class Meta:\n        \"\"\"Model settings.\"\"\"\n\n        unique_together = (\"name\", \"extension\")\n\n    def __str__(self):\n        \"\"\"Return the string representation.\"\"\"\n        name = self.label if self.label else self.name\n        if self.extension:\n            return f\"{self.extension.label}: {name}\"\n        return name\n\n    def save(self, *args, **kwargs):\n        \"\"\"Set name to be the same as label if no name is given.\"\"\"\n        if not self.name:\n            self.name = self.label.replace(\" \", \"_\").lower()\n        if not self.label:\n            self.label = self.name.replace(\"_\", \" \").capitalize()\n        super().save(*args, **kwargs)\n</code></pre>"},{"location":"extensions/core/#collectivo.core.models.PermissionGroup","title":"<code>PermissionGroup</code>","text":"<p>A group of permissions that can be assigned to users.</p> Source code in <code>collectivo/core/models.py</code> <pre><code>class PermissionGroup(models.Model):\n    \"\"\"A group of permissions that can be assigned to users.\"\"\"\n\n    name = models.CharField(max_length=255)\n    label = models.CharField(max_length=255, blank=True)\n    description = models.TextField(blank=True)\n    permissions = models.ManyToManyField(\n        \"Permission\", related_name=\"groups\", blank=True\n    )\n    users = models.ManyToManyField(\n        User, related_name=\"permission_groups\", blank=True\n    )\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.CASCADE,\n        related_name=\"permission_groups\",\n        null=True,\n        blank=True,\n        help_text=EXTENSION_HELP_TEXT,\n    )\n    users_custom = models.BooleanField(\n        default=True,\n        verbose_name=\"Custom users\",\n        help_text=\"If checked, users can be added to this group manually.\",\n    )\n    perms_custom = models.BooleanField(\n        default=True,\n        verbose_name=\"Custom permissions\",\n        help_text=(\n            \"If checked, permissions can be added to this group manually.\"\n        ),\n    )\n    history = HistoricalRecords()\n    objects = NameManager()\n\n    class Meta:\n        \"\"\"Model settings.\"\"\"\n\n        unique_together = (\"name\", \"extension\")\n\n    def __str__(self):\n        \"\"\"Return the string representation.\"\"\"\n        name = self.label if self.label else self.name\n        if self.extension:\n            return f\"{self.extension.label}: {name}\"\n        return name\n\n    def save(self, *args, **kwargs):\n        \"\"\"Set name to be the same as label if no name is given.\"\"\"\n        if not self.name:\n            self.name = self.label.replace(\" \", \"_\").lower()\n        if not self.label:\n            self.label = self.name.replace(\"_\", \" \").capitalize()\n        super().save(*args, **kwargs)\n</code></pre>"},{"location":"extensions/core/#collectivo.core.models.CoreSettings","title":"<code>CoreSettings</code>","text":"<p>Settings for the core extension.</p> Source code in <code>collectivo/core/models.py</code> <pre><code>class CoreSettings(SingleInstance, models.Model):\n    \"\"\"Settings for the core extension.\"\"\"\n\n    history = HistoricalRecords()\n\n    project_name = models.CharField(\n        max_length=255,\n        default=\"My community plattform\",\n        blank=True,\n    )\n    project_description = models.TextField(\n        blank=True,\n    )\n    project_logo = models.ImageField(\n        upload_to=\"core/logo/\",\n        null=True,\n        blank=True,\n        verbose_name=\"Project logo (File upload)\",\n    )\n    project_logo_url = models.URLField(\n        blank=True,\n        verbose_name=\"Project logo (URL)\",\n    )\n\n    display_project_name = models.BooleanField(\n        default=False,\n        verbose_name=\"Display project name\",\n    )\n    display_project_description = models.BooleanField(\n        default=False,\n        verbose_name=\"Display project description\",\n    )\n    display_project_logo = models.BooleanField(\n        default=True,\n        verbose_name=\"Display project logo\",\n    )\n</code></pre>"},{"location":"extensions/dashboard/","title":"Dashboard","text":"<p>Create a starting page for your plattform with a dashboard that can display custom tiles.</p>"},{"location":"extensions/dashboard/#installation","title":"Installation","text":"<p>Add <code>collectivo.dashboard</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/dashboard/#usage-by-other-extensions","title":"Usage by other extensions","text":"<p>A dashboard tile and tile button can be registered by a custom extension as follows:</p> <pre><code>from collectivo.extensions.models import Extension\nfrom collectivo.dashboard.models import DashboardTile, DashboardTileButton\n\nmy_extension = Extension.objects.get(name=\"my_extension\")\n\ntile = DashboardTile.objects.register(\n    name=\"my_extension_welcome_tile\",\n    label=\"My extension tile\",\n    extension=my_extension,\n    source=\"db\",\n    order=0,\n    content=(\n        \"Welcome {{ user.first_name }} {{ user.last_name }}. \"\n        \"This tile has been created by my_extension.\"\n    ),\n)\n\nbutton = DashboardTileButton.objects.register(\n    name=f\"example_button_{i}\",\n    label=f\"Example Button {i}\",\n)\n\ntile.buttons.set([button])\n</code></pre>"},{"location":"extensions/dashboard/#reference","title":"Reference","text":""},{"location":"extensions/dashboard/#collectivo.dashboard.models.DashboardTile","title":"<code>DashboardTile</code>","text":"<p>A component that can be included in the dashboard.</p> Source code in <code>collectivo/dashboard/models.py</code> <pre><code>class DashboardTile(NameLabelModel, models.Model):\n    \"\"\"A component that can be included in the dashboard.\"\"\"\n\n    class Meta:\n        \"\"\"Meta settings.\"\"\"\n\n        unique_together = (\"name\", \"extension\")\n\n    objects = DashboardTileManager()\n    history = HistoricalRecords()\n\n    name = models.CharField(max_length=255, unique=True)\n    label = models.CharField(max_length=255, null=True, blank=True)\n    active = models.BooleanField(default=True)\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n    )\n\n    order = models.FloatField(default=1)\n    requires_perm = models.ForeignKey(\n        \"core.Permission\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n        related_name=\"requires_perm\",\n        help_text=(\n            \"If set, the object will only be displayed to users with \"\n            \"this permission.\"\n        ),\n    )\n    requires_not_perm = models.ForeignKey(\n        \"core.Permission\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n        related_name=\"requires_not_perm\",\n        help_text=(\n            \"If set, the object will only be displayed to users without \"\n            \"this permission.\"\n        ),\n    )\n\n    source = models.CharField(\n        max_length=255,\n        choices=[\n            (\"db\", \"Content is defined in the content field of this model.\"),\n            (\"component\", \"Content is defined in a webcomponent.\"),\n        ],\n    )\n    component = models.CharField(max_length=255, blank=True)\n    content = models.TextField(\n        blank=True,\n        help_text=\"HTML content to display inside the tile.\",\n    )\n    buttons = models.ManyToManyField(\n        DashboardTileButton,\n        blank=True,\n        help_text=\"Buttons to display inside the tile.\",\n    )\n\n    def __str__(self):\n        \"\"\"Return string representation of the model.\"\"\"\n        return self.name\n</code></pre>"},{"location":"extensions/dashboard/#collectivo.dashboard.models.DashboardTileButton","title":"<code>DashboardTileButton</code>","text":"<p>A button that can be included in a dashboard tile.</p> Source code in <code>collectivo/dashboard/models.py</code> <pre><code>class DashboardTileButton(NameLabelModel, models.Model):\n    \"\"\"A button that can be included in a dashboard tile.\"\"\"\n\n    class Meta:\n        \"\"\"Meta settings.\"\"\"\n\n        unique_together = (\"name\", \"extension\")\n\n    objects = NameManager()\n    history = HistoricalRecords()\n\n    name = models.CharField(\n        max_length=255, unique=True, null=True, default=None\n    )\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.CASCADE,\n        null=True,\n        blank=True,\n    )\n    label = models.CharField(max_length=255, null=True, blank=True)\n    link = models.CharField(max_length=255, null=True, blank=True)\n    link_type = models.CharField(\n        max_length=255,\n        choices=[\n            (\"internal\", \"Internal link\"),\n            (\"external\", \"External link\"),\n        ],\n    )\n</code></pre>"},{"location":"extensions/emails/","title":"Emails","text":"<p>Manage email campaigns and send automated emails to your users.</p>"},{"location":"extensions/emails/#installation","title":"Installation","text":"<p>Add <code>collectivo.emails</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/emails/#reference","title":"Reference","text":""},{"location":"extensions/emails/#collectivo.emails.models.EmailCampaign","title":"<code>EmailCampaign</code>","text":"<p>An email campaign that can be used to send mass emails.</p> Source code in <code>collectivo/emails/models.py</code> <pre><code>class EmailCampaign(models.Model):\n    \"\"\"An email campaign that can be used to send mass emails.\"\"\"\n\n    history = HistoricalRecords()\n\n    template = models.ForeignKey(\n        \"emails.EmailTemplate\", on_delete=models.SET_NULL, null=True\n    )\n    status = models.CharField(\n        max_length=10,\n        default=\"draft\",\n        choices=[\n            (\"draft\", \"draft\"),\n            (\"pending\", \"pending\"),\n            (\"success\", \"success\"),\n            (\"failure\", \"failure\"),\n        ],\n    )\n    status_message = models.CharField(max_length=255, null=True)\n    sent = models.DateTimeField(null=True)\n    recipients = models.ManyToManyField(\n        get_user_model(), related_name=\"emails\"\n    )\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.SET_NULL,\n        null=True,\n        blank=True,\n        help_text=\"The extension that created this campaign.\",\n    )\n\n    def __str__(self):\n        \"\"\"Return a string representation of the object.\"\"\"\n        return f\"{self.template.name} ({self.sent})\"\n\n    def send(self, context=None):\n        \"\"\"Send emails to recipients.\"\"\"\n        self.sent = timezone.now()\n        self.status = \"pending\"\n        self.save()\n\n        # Generate emails from template\n        email_batches = self.create_email_batches(context=context)\n\n        # Create a chain of async tasks to send emails\n        results = {\"n_sent\": 0, \"campaign\": self}\n        tasks = []\n        tasks.append(send_mails_async.s(results, email_batches.pop(0)))\n        for email_batch in email_batches:\n            tasks.append(send_mails_async.s(email_batch))\n        tasks.append(send_mails_async_end.s())\n        try:\n            chain(*tasks)()\n        except Exception as e:\n            self.status = \"failure\"\n            self.status_message = str(e)\n            self.save()\n            raise e\n\n    def create_email_batches(self, context=None):\n        \"\"\"Create a list of emails, split into batches.\"\"\"\n        emails = []\n        for recipient in self.recipients.all():\n            if recipient.email in (None, \"\"):\n                self.status = \"failure\"\n                self.status_message = f\"{recipient} has no email.\"\n                self.save()\n                raise ValueError(self.status_message)\n            email = self.template.render(recipient, context=context)\n            emails.append(email)\n\n        # Split recipients into batches\n        n = 20  # TODO Get this number from the settings\n        return [emails[i : i + n] for i in range(0, len(emails), n)]\n\n    def get_backend_config_kwargs(self):\n        \"\"\"Return the email backend config args for this sender config.\n\n        These need to be passed to `core.django.mail.get_connection(**kwargs)`\n        \"\"\"\n        if self.template.sender_config is not None:\n            return self.template.sender_config.get_backend_config_kwargs()\n        else:\n            # Return the default backend using the values from settings.py\n            return {}\n</code></pre>"},{"location":"extensions/emails/#collectivo.emails.models.EmailTemplate","title":"<code>EmailTemplate</code>","text":"<p>A template of an email, which can be applied to a campaign.</p> Source code in <code>collectivo/emails/models.py</code> <pre><code>class EmailTemplate(models.Model):\n    \"\"\"A template of an email, which can be applied to a campaign.\"\"\"\n\n    objects = NameManager()\n    history = HistoricalRecords()\n\n    name = models.CharField(max_length=255, unique=\"True\")\n    design = models.ForeignKey(\n        \"emails.EmailDesign\", on_delete=models.PROTECT, null=True\n    )\n    subject = models.CharField(max_length=255)\n    body = models.TextField()\n    sender_config = models.ForeignKey(\n        \"emails.EmailSenderConfig\", on_delete=models.SET_NULL, null=True\n    )\n\n    def __str__(self):\n        \"\"\"Return a string representation of the object.\"\"\"\n        return self.name\n\n    def render(self, recipient, context=None):\n        \"\"\"Render the email template for the given recipient.\"\"\"\n        if self.design is not None:\n            body_with_design_applied = self.design.apply(self.body)\n        else:\n            body_with_design_applied = self.body\n\n        if self.sender_config is not None:\n            from_email = self.sender_config.from_email\n        else:\n            from_email = settings.DEFAULT_FROM_EMAIL\n\n        body_html = Template(body_with_design_applied).render(\n            Context({\"user\": recipient, **(context or {})})\n        )\n        body_text = html2text(body_html)\n        email = EmailMultiAlternatives(\n            self.subject, body_text, from_email, [recipient.email]\n        )\n        email.attach_alternative(body_html, \"text/html\")\n        return email\n</code></pre>"},{"location":"extensions/emails/#collectivo.emails.models.EmailDesign","title":"<code>EmailDesign</code>","text":"<p>A design of an email, which can be applied to a template.</p> Source code in <code>collectivo/emails/models.py</code> <pre><code>class EmailDesign(models.Model):\n    \"\"\"A design of an email, which can be applied to a template.\"\"\"\n\n    objects = NameManager()\n    history = HistoricalRecords()\n\n    name = models.CharField(max_length=255, unique=\"True\")\n    body = models.TextField()\n\n    def __str__(self):\n        \"\"\"Return a string representation of the object.\"\"\"\n        return self.name\n\n    def apply(self, content):\n        \"\"\"Apply this design to the given content.\"\"\"\n        return self.body.replace(\"{{content}}\", content)\n</code></pre>"},{"location":"extensions/emails/#collectivo.emails.models.EmailAutomation","title":"<code>EmailAutomation</code>","text":"<p>An automation that sends emails to users.</p> Source code in <code>collectivo/emails/models.py</code> <pre><code>class EmailAutomation(models.Model):\n    \"\"\"An automation that sends emails to users.\"\"\"\n\n    class Meta:\n        \"\"\"Model settings.\"\"\"\n\n        unique_together = (\"name\", \"extension\")\n\n    objects = NameManager()\n    history = HistoricalRecords()\n\n    name = models.CharField(max_length=255)\n    label = models.CharField(max_length=255)\n    is_active = models.BooleanField(\n        default=False,\n        verbose_name=\"Active\",\n        help_text=(\n            \"If checked, this automation will be active and send emails.\"\n        ),\n    )\n    description = models.TextField()\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.CASCADE,\n    )\n    admin_only = models.BooleanField(default=False)\n\n    template = models.ForeignKey(\n        \"emails.EmailTemplate\",\n        on_delete=models.PROTECT,\n        null=True,\n        blank=True,\n        related_name=\"automations\",\n    )\n\n    admin_template = models.ForeignKey(\n        \"emails.EmailTemplate\",\n        on_delete=models.PROTECT,\n        null=True,\n        blank=True,\n        related_name=\"automations_admin\",\n    )\n\n    admin_recipients = models.ManyToManyField(\n        get_user_model(),\n        verbose_name=\"Recipients\",\n        related_name=\"admin_email_automations\",\n        blank=True,\n    )\n\n    def send(self, recipients, context=None):\n        \"\"\"Send emails to recipients.\"\"\"\n        if self.is_active:\n            # Generate email campaign for admins from automation\n            if (self.admin_recipients.exists()):\n                admin_campaign = EmailCampaign.objects.create(\n                    template=self.admin_template,\n                    extension=self.extension,\n                )\n                admin_campaign.recipients.set(self.admin_recipients.all())\n                admin_campaign.save()\n                admin_campaign.send(context=context)\n\n            if not self.admin_only:\n                # Generate email campaign for end users from automation\n                user_campaign = EmailCampaign.objects.create(\n                    template=self.template,\n                    extension=self.extension,\n                )\n                user_campaign.recipients.set(recipients)\n                user_campaign.save()\n                user_campaign.send(context=context)\n</code></pre>"},{"location":"extensions/extensions/","title":"Extensions","text":"<p>Manage extensions. This extension is required to register other extensions.</p>"},{"location":"extensions/extensions/#installation","title":"Installation","text":"<p>Add <code>collectivo.extensions</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/extensions/#usage-by-other-extensions","title":"Usage by other extensions","text":"<p>A custom extension can register itself as follows:</p> <pre><code>from collectivo.extensions.models import Extension\n\nExtension.objects.register(\n    name='my_extension',\n    description='This is my first custom extension.',\n)\n</code></pre>"},{"location":"extensions/extensions/#reference","title":"Reference","text":""},{"location":"extensions/extensions/#collectivo.extensions.models.Extension","title":"<code>Extension</code>","text":"<p>An extension that can add additional functionalities to collectivo.</p> Source code in <code>collectivo/extensions/models.py</code> <pre><code>class Extension(models.Model):\n    \"\"\"An extension that can add additional functionalities to collectivo.\"\"\"\n\n    objects = ExtensionManager()\n\n    name = models.CharField(\n        max_length=255, unique=True, help_text=\"Unique name of the extension.\"\n    )\n    label = models.CharField(\n        max_length=255, blank=True, help_text=\"Label to display the extension.\"\n    )\n    description = models.TextField(\n        blank=True, help_text=\"Description of the extension and its features.\"\n    )\n    built_in = models.BooleanField(\n        default=False, help_text=\"Whether the extension is part of collectivo.\"\n    )\n    version = models.CharField(\n        max_length=255, blank=True, help_text=\"Version of the extension.\"\n    )\n    active = models.BooleanField(\n        default=True, help_text=\"Whether the extension is active.\"\n    )\n\n    def __str__(self):\n        \"\"\"Return string representation of the model.\"\"\"\n        return self.name\n</code></pre>"},{"location":"extensions/keycloak/","title":"Keycloak","text":"<p>Enable authentication with keycloak and python-keycloak. Keycloak access tokens can be used to authenticate requests and user data is synchronized between collectivo and keycloak.</p>"},{"location":"extensions/keycloak/#installation","title":"Installation","text":"<p>Add the following entry to <code>collectivo.yml</code>:</p> <pre><code>- extensions:\n  - collectivo.auth.keycloak:\n      - server_url:     # Path towards the keycloak server\n      - realm_name:     # Realm name the collectivo client\n      - client_id:      # Name of the collectivo client\n      - client_secret:  # Secret key of the collectivo client\n</code></pre> <p>When keycloak is not correctly configured, a warning will appear in the logs.</p>"},{"location":"extensions/memberships/","title":"Memberships","text":"<p>Manage memberships and membership applications.</p> <p>Key features:</p> <ul> <li>Multiple types of membership can be defined with different possible status options. For example, there can be a type <code>Member of Organisation 1</code> with the options <code>active</code> and <code>passive</code> and a type <code>Member of Organisation 2</code> with the options <code>active</code>, <code>passive</code>, and <code>honorary</code>.</li> <li>Users can apply for a membership through the platform. Each membership type can have its own application form. This form can be customized and combined with other extensions (see custom registration form).</li> <li>The life cycle of a membership is captured with the variable <code>stage</code>, which can be set to <code>applied</code>, <code>accepted</code>, <code>resigned</code>, <code>excluded</code>, and <code>ended</code>.</li> <li>If the emails extension is installed, automatic emails can be configrued to send a message to the user when a membership is started or changed.</li> <li>Memberships can require shares that have to be payed once to join the organization, with the possibility to sign additional shares later on. They can also require regular fees that have to be payed periodically. For both cases, automatic invoices are generated if the payments extension is installed.</li> </ul> <p>Limitations:</p> <ul> <li>The current application form only supports choosing a free number of custom shares. This can be extended with a custom registration form.</li> </ul>"},{"location":"extensions/memberships/#installation","title":"Installation","text":"<p>Add <code>collectivo.emails</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/memberships/#custom-registration-form","title":"Custom registration form","text":"<p>The setting <code>registration_serializers</code> can be used to add additional pages to the registration form. Entries can be <code>create</code> (to create a new object) or <code>update</code> (to update an existing object) and must define a path to a <code>ModelSerializer</code>.</p> <p>In the following example, the registration form will consist of two pages to update the user's <code>Profile</code> and <code>PaymentProfile</code> and a third page with the default serializer to create a new <code>Membership</code>.</p> collectivo.yml<pre><code>- extensions:\n  - collectivo.memberships:\n      - registration_serializers:\n          - update: collectivo.profiles.serializers.ProfileRegisterSerializer\n          - update: collectivo.payments.serializers.PaymentProfileSerializer\n          - create: collectivo.memberships.serializers.MembershipRegisterSerializer\n</code></pre> <p>Custom extensions can be used to define additional serializers. The following rules apply:</p> <ul> <li> <p>Each serializer must have a unique field <code>user</code> that will automatically be set to the currently authenticated user. When <code>update</code> is used, the model instance to be updated is selected based on the user.</p> </li> <li> <p>The schema for <code>Membership</code> will be overridden to include the status options and other data of the membership type. E.g. if the user is applying for a membership type with the status options <code>active</code> and <code>passive</code>, then this type will automatically be selected when submitting the form and the schema for the <code>status</code> field will be overridden to only allow <code>active</code> and <code>passive</code> as values.</p> </li> </ul>"},{"location":"extensions/memberships/#reference","title":"Reference","text":""},{"location":"extensions/memberships/#collectivo.memberships.models.Membership","title":"<code>Membership</code>","text":"<p>A membership of a user.</p> Source code in <code>collectivo/memberships/models.py</code> <pre><code>class Membership(models.Model):\n    \"\"\"A membership of a user.\"\"\"\n\n    class Meta:\n        \"\"\"Meta settings.\"\"\"\n\n        unique_together = [(\"number\", \"type\"), (\"user\", \"type\")]\n\n    user = models.ForeignKey(\n        get_user_model(),\n        on_delete=models.CASCADE,\n        related_name=\"memberships\",\n    )\n    number = models.IntegerField(verbose_name=\"Membership number\")\n\n    date_applied = models.DateField(null=True, blank=True, default=date.today)\n    date_accepted = models.DateField(null=True, blank=True)\n    date_resigned = models.DateField(null=True, blank=True)\n    date_excluded = models.DateField(null=True, blank=True)\n    date_ended = models.DateField(null=True, blank=True)\n\n    type = models.ForeignKey(\n        \"MembershipType\", on_delete=models.PROTECT, related_name=\"memberships\"\n    )\n    status = models.ForeignKey(\n        \"MembershipStatus\", null=True, blank=True, on_delete=models.PROTECT\n    )\n    stage = models.CharField(\n        max_length=20,\n        choices=[(x, x) for x in MEMBERSHIP_STAGES],\n        default=\"applied\",\n    )\n\n    # Optional depending on membership type\n    shares_signed = models.PositiveIntegerField(default=0)\n    shares_paid = models.PositiveIntegerField(default=0)\n    fees_amount = models.DecimalField(\n        max_digits=100, decimal_places=2, default=0\n    )\n    comembership_of = models.ForeignKey(\n        \"Membership\", blank=True, null=True, on_delete=models.CASCADE\n    )\n\n    history = HistoricalRecords()\n\n    def generate_membership_number(self):\n        \"\"\"Generate a unique membership number.\"\"\"\n        highest_number = (\n            Membership.objects.filter(type=self.type).order_by(\"number\").last()\n        )\n        return 1 if highest_number is None else highest_number.number + 1\n\n    def save_basic(self, *args, **kwargs):\n        \"\"\"Save membership and generate membership number.\"\"\"\n        if self.number is None:\n            self.number = self.generate_membership_number()\n\n        super().save()\n\n    def save(self, *args, **kwargs):\n        \"\"\"Save membership and create payments.\"\"\"\n        self.create_invoices()\n        self.assign_group()\n\n        # Store data before saving\n        old = Membership.objects.filter(pk=self.pk)\n        old_data = {field.name: None for field in self._meta.fields}\n        is_new = False if old.exists() else True\n        if not is_new:\n            for field in self._meta.fields:\n                old_data[field] = getattr(old.first(), field.name)\n\n        # Create or update object\n        self.save_basic()\n\n        self.send_emails(is_new, old_data)\n\n    def send_emails(self, new, data):\n        \"\"\"Send automatic emails.\"\"\"\n\n        # Trigger automation if membership stage has changed\n        if data[\"stage\"] != self.stage:\n            self.send_email(f\"membership_{self.stage}\")\n\n        # Trigger automation for changes in shares\n        if (self.shares_paid or 0) &gt; (data[\"shares_paid\"] or 0):\n            self.send_email(\"paid_shares_increased\")\n        elif (self.shares_paid or 0) &lt; (data[\"shares_paid\"] or 0):\n            self.send_email(\"paid_shares_decreased\")\n        if (self.shares_paid or 0) &gt; (data[\"shares_signed\"] or 0):\n            self.send_email(\"signed_shares_increased\")\n        elif (self.shares_signed or 0) &lt; (data[\"shares_signed\"] or 0):\n            self.send_email(\"signed_shares_decreased\")\n\n    def delete(self, *args, **kwargs):\n        \"\"\"Delete the model and remove registration.\"\"\"\n        self.assign_group(remove=True)\n        super().delete(*args, **kwargs)\n\n    def __str__(self):\n        \"\"\"Return string representation.\"\"\"\n        return (\n            f\"{self.user.first_name} {self.user.last_name} ({self.type.name})\"\n        )\n\n    def assign_group(self, remove=False):\n        \"\"\"Assign the user to the group of the membership type.\"\"\"\n        extension = Extension.objects.get(name=\"memberships\")\n        group = PermissionGroup.objects.get(\n            name=self.type.short_name,\n            extension=extension,\n        )\n        if remove:\n            group.users.remove(self.user)\n        else:\n            group.users.add(self.user)\n        group.save()\n\n    def send_email(self, trigger):\n        \"\"\"Send automatic email.\"\"\"\n        self.type.refresh_from_db()\n        from collectivo.emails.models import EmailAutomation\n        from collectivo.extensions.models import Extension\n\n        extension = Extension.objects.get(name=\"memberships\")\n\n        automation = EmailAutomation.objects.get(\n            name=trigger, extension=extension\n        )\n        automation.send([self.user], context={\"membership\": self})\n\n    def update_shares_paid(self):\n        \"\"\"Update the number of shares paid for this membership.\n\n        This method depends to the collectivo.payments extension.\n        \"\"\"\n\n        if not payments_installed:\n            raise ExtensionNotInstalled(\"collectivo.payments\")\n\n        extension = Extension.objects.get(name=\"memberships\")\n        item_category = ItemTypeCategory.objects.get_or_create(\n            name=\"Shares\", extension=extension\n        )[0]\n        item_type = ItemType.objects.get_or_create(\n            reference=self.type.id,\n            category=item_category,\n            extension=extension,\n        )[0]\n        item_type.name = self.type.name\n        item_type.save()\n        entries = ItemEntry.objects.filter(\n            type=item_type,\n            invoice__payment_from=self.user.account,\n            invoice__status=\"paid\",\n        )\n        if entries.exists():\n            shares_paid = (\n                sum([entry.amount * entry.price for entry in entries])\n                / self.type.shares_amount_per_share\n            )\n\n            self.shares_paid = shares_paid\n            self.save_basic()\n\n    def create_invoices(self):\n        \"\"\"Create invoices for this membership.\n\n        This method depends to the collectivo.payments extension.\n        \"\"\"\n\n        if not payments_installed:\n            raise ExtensionNotInstalled(\"collectivo.payments\")\n\n        # Create invoices for shares\n        if self.type.has_shares:\n            extension = Extension.objects.get(name=\"memberships\")\n            item_category = ItemTypeCategory.objects.get_or_create(\n                name=\"Shares\", extension=extension\n            )[0]\n            item_type = ItemType.objects.get_or_create(\n                reference=self.type.id,\n                category=item_category,\n                extension=extension,\n            )[0]\n            item_type.name = self.type.name\n            item_type.save()\n            entries = ItemEntry.objects.filter(\n                type=item_type,\n                invoice__payment_from=self.user.account,\n            )\n\n            # Get current status\n            invoiced = sum([entry.amount * entry.price for entry in entries])\n            to_pay = self.type.shares_amount_per_share * self.shares_signed\n\n            # Create invoice if needed\n            if invoiced &lt; to_pay:\n                invoice = Invoice.objects.create(\n                    payment_from=self.user.account,\n                    status=\"open\",\n                )\n                price = self.type.shares_amount_per_share\n                ItemEntry.objects.create(\n                    invoice=invoice,\n                    type=item_type,\n                    amount=(to_pay - invoiced) / price,\n                    price=price,\n                )\n\n        # Create subscriptions for fees\n        if self.type.has_fees:\n            extension = Extension.objects.get(name=\"memberships\")\n            item_category = ItemTypeCategory.objects.get_or_create(\n                name=\"Fees\", extension=extension\n            )[0]\n            item_type = ItemType.objects.get_or_create(\n                reference=self.type.id,\n                category=item_category,\n                extension=extension,\n            )[0]\n            item_type.name = self.type.name\n            item_type.save()\n            entries = ItemEntry.objects.filter(\n                type=item_type,\n                subscription__status=\"active\",\n                subscription__payment_from=self.user.account,\n            )\n\n            # Create or update subscription\n            if entries.exists():\n                entry = entries.first()\n                subscription = entry.subscription\n\n                subscription.status = \"active\"\n                subscription.repeat_each = self.type.fees_repeat_each\n                subscription.repeat_unit = self.type.fees_repeat_unit\n                subscription.save()\n\n                entry.amount = 1\n                entry.price = self.fees_amount\n                entry.save()\n\n            else:\n                subscription = Subscription.objects.create(\n                    payment_from=self.user.account,\n                    status=\"active\",\n                    extension=extension,\n                    date_started=self.date_applied,\n                    repeat_each=self.type.fees_repeat_each,\n                    repeat_unit=self.type.fees_repeat_unit,\n                )\n                price = self.fees_amount\n                ItemEntry.objects.create(\n                    subscription=subscription,\n                    type=item_type,\n                    amount=1,\n                    price=self.fees_amount,\n                )\n</code></pre>"},{"location":"extensions/memberships/#collectivo.memberships.models.MembershipType","title":"<code>MembershipType</code>","text":"<p>A type of membership.</p> Source code in <code>collectivo/memberships/models.py</code> <pre><code>class MembershipType(models.Model):\n    \"\"\"A type of membership.\"\"\"\n\n    objects = NameManager()\n\n    name = models.CharField(max_length=255, unique=True)\n    description = models.TextField(null=True, blank=True)\n\n    # TODO: Validation for this field\n    statuses = models.ManyToManyField(\n        \"MembershipStatus\",\n        help_text=\"The statuses that a membership of this type can have.\",\n        blank=True,\n    )\n\n    has_shares = models.BooleanField(\n        default=False,\n        help_text=\"Whether users need to buy shares to become members.\",\n    )\n    shares_amount_per_share = models.DecimalField(\n        max_digits=100,\n        decimal_places=2,\n        null=True,\n        blank=True,\n        help_text=\"The amount of money that has to be paid per share.\",\n    )\n    shares_number_custom = models.BooleanField(\n        default=False,\n        help_text=\"Whether members can choose a custom number of shares.\",\n    )\n    shares_number_custom_min = models.IntegerField(\n        null=True,\n        blank=True,\n        help_text=\"The minimum number of shares for custom numbers of shares.\",\n    )\n    shares_number_custom_max = models.IntegerField(\n        null=True,\n        blank=True,\n        help_text=\"The maximum number of shares for custom numbers of shares.\",\n    )\n    shares_number_standard = models.IntegerField(\n        null=True, blank=True, help_text=\"The default number of shares.\"\n    )\n    shares_number_social = models.IntegerField(\n        null=True,\n        blank=True,\n        help_text=\"A reduced number of shares.\",\n    )\n\n    has_fees = models.BooleanField(default=False)\n    fees_amount_custom = models.BooleanField(default=False)\n    fees_amount_custom_min = models.DecimalField(\n        max_digits=100, decimal_places=2, null=True, blank=True\n    )\n    fees_amount_custom_max = models.DecimalField(\n        max_digits=100, decimal_places=2, null=True, blank=True\n    )\n    fees_amount_standard = models.DecimalField(\n        max_digits=100, decimal_places=2, null=True, blank=True\n    )\n    fees_amount_social = models.DecimalField(\n        max_digits=100, decimal_places=2, null=True, blank=True\n    )\n    fees_repeat_each = models.IntegerField(default=1)\n    fees_repeat_unit = models.CharField(\n        max_length=20,\n        default=\"year\",\n        choices=[\n            (\"year\", \"year\"),\n            (\"month\", \"month\"),\n            (\"week\", \"week\"),\n            (\"day\", \"day\"),\n        ],\n    )\n\n    currency = models.CharField(\n        max_length=3,\n        default=\"EUR\",\n        help_text=\"The currency used for fees and shares.\",\n    )\n\n    comembership_of = models.ForeignKey(\n        \"MembershipType\", null=True, blank=True, on_delete=models.CASCADE\n    )\n    comembership_max = models.IntegerField(null=True, blank=True)\n\n    enable_registration = models.BooleanField(\n        default=False,\n        verbose_name=\"Enable registration\",\n        help_text=\"Whether users can register for this membership type.\",\n    )\n\n    history = HistoricalRecords()\n\n    def __str__(self):\n        \"\"\"Return string representation.\"\"\"\n        return self.name\n\n    def save(self, *args, **kwargs):\n        \"\"\"Save the model and set up registration.\"\"\"\n        with transaction.atomic():\n            super().save(*args, **kwargs)\n            self.create_group()\n            if self.enable_registration:\n                self.create_registration_form()\n            else:\n                self.delete_registration_form()\n\n    @property\n    def short_name(self):\n        \"\"\"Return a short name to identify the membership programmatically.\"\"\"\n        return f\"membership_type_{self.id}\"\n\n    def delete(self, *args, **kwargs):\n        \"\"\"Delete the model and remove registration.\"\"\"\n        self.delete_group()\n        self.delete_registration_form()\n        super().delete(*args, **kwargs)\n\n    def create_group(self, remove=False):\n        \"\"\"Handle the group for this membership type.\"\"\"\n        extension = Extension.objects.get(name=\"memberships\")\n        permission = Permission.objects.register(\n            name=self.short_name,\n            label=self.name,\n            extension=extension,\n        )\n        group = PermissionGroup.objects.register(\n            name=self.short_name,\n            label=self.name,\n            description=(\n                \"Members of this group have a membership of the type '{}'.\"\n                .format(self.name)\n            ),\n            extension=extension,\n            users_custom=False,\n            perms_custom=True,\n        )\n        group.permissions.add(permission)\n        group.save()\n\n    def delete_group(self):\n        \"\"\"Delete the group for this membership type.\"\"\"\n        extension = Extension.objects.get(name=\"memberships\")\n        try:\n            Permission.objects.get(\n                name=self.short_name, extension=extension\n            ).delete()\n        except Permission.DoesNotExist:\n            pass\n\n        try:\n            PermissionGroup.objects.get(\n                name=self.short_name, extension=extension\n            ).delete()\n        except PermissionGroup.DoesNotExist:\n            pass\n\n    def create_registration_form(self):\n        \"\"\"Create a registration form for this membership type.\"\"\"\n\n        extension = Extension.objects.get(name=\"memberships\")\n\n        permission = Permission.objects.get(\n            name=self.short_name, extension=extension\n        )\n\n        tile = DashboardTile.objects.register(\n            name=self.short_name,\n            label=\"Membership application\",\n            extension=extension,\n            source=\"db\",\n            content=\"Click here to register as a member of {}.\".format(\n                self.name\n            ),\n            requires_not_perm=permission,\n        )\n\n        button = DashboardTileButton.objects.register(\n            name=self.short_name,\n            label=\"Register\",\n            extension=Extension.objects.get(name=\"memberships\"),\n            link_type=\"internal\",\n            link=\"memberships/register/{}/1\".format(self.id),\n        )\n\n        tile.buttons.add(button)\n\n    def delete_registration_form(self):\n        \"\"\"Delete the registration form for this membership type.\"\"\"\n        extension = Extension.objects.get(name=\"memberships\")\n\n        try:\n            DashboardTile.objects.get(\n                name=self.short_name, extension=extension\n            ).delete()\n        except DashboardTile.DoesNotExist:\n            pass\n\n        try:\n            DashboardTileButton.objects.get(\n                name=self.short_name, extension=extension\n            ).delete()\n        except DashboardTileButton.DoesNotExist:\n            pass\n</code></pre>"},{"location":"extensions/memberships/#collectivo.memberships.models.MembershipStatus","title":"<code>MembershipStatus</code>","text":"<p>A status of a membership (sub-type).</p> Source code in <code>collectivo/memberships/models.py</code> <pre><code>class MembershipStatus(models.Model):\n    \"\"\"A status of a membership (sub-type).\"\"\"\n\n    objects = NameManager()\n\n    name = models.CharField(unique=True, max_length=255)\n    history = HistoricalRecords()\n\n    def __str__(self):\n        \"\"\"Return string representation.\"\"\"\n        return self.name\n</code></pre>"},{"location":"extensions/menus/","title":"Menus","text":"<p>Manage menus and menu items.</p>"},{"location":"extensions/menus/#installation","title":"Installation","text":"<p>Add <code>collectivo.menus</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/menus/#usage-by-other-extensions","title":"Usage by other extensions","text":"<p>A menu and menu item can be registered by a custom extension as follows:</p> <pre><code>from collectivo.extensions.models import Extension\nfrom collectivo.menus.models import Menu, MenuItem\n\nmy_extension = Extension.objects.get(name=\"my_extension\")\n\nMenu.objects.register(name=\"main\", extension=my_extension)\n\nMenuItem.objects.register(\n    name=\"my_menu_item\",\n    label=\"My menu item\",\n    extension=my_extension,\n    route=\"my_extension/my_component\",\n    icon_name=\"pi-user\",  # See https://primevue.org/icons/\n    parent=\"main\",\n    order=1,\n)\n</code></pre> <p>The menus <code>main</code> and <code>admin</code> are registered by the core extension and will be displayed in the sidebar of the frontend application.</p>"},{"location":"extensions/menus/#reference","title":"Reference","text":""},{"location":"extensions/menus/#collectivo.menus.models.Menu","title":"<code>Menu</code>","text":"<p>A menu to be displayed in the user interface.</p> Source code in <code>collectivo/menus/models.py</code> <pre><code>class Menu(models.Model):\n    \"\"\"A menu to be displayed in the user interface.\"\"\"\n\n    class Meta:\n        \"\"\"Model settings.\"\"\"\n\n        unique_together = (\"name\", \"extension\")\n\n    objects = MenuManager()\n    name = models.CharField(max_length=255)\n    extension = models.ForeignKey(\n        \"extensions.Extension\", on_delete=models.CASCADE\n    )\n\n    items = models.ManyToManyField(\"menus.MenuItem\")\n</code></pre>"},{"location":"extensions/menus/#collectivo.menus.models.MenuItem","title":"<code>MenuItem</code>","text":"<p>An item to be displayed in a menu.</p> Source code in <code>collectivo/menus/models.py</code> <pre><code>class MenuItem(models.Model):\n    \"\"\"An item to be displayed in a menu.\"\"\"\n\n    class Meta:\n        \"\"\"Model settings.\"\"\"\n\n        unique_together = (\"name\", \"extension\")\n\n    objects = MenuManager()\n    name = models.CharField(max_length=255)\n    extension = models.ForeignKey(\n        \"extensions.Extension\", on_delete=models.CASCADE\n    )\n\n    label = models.CharField(max_length=255)\n    items = models.ManyToManyField(\"self\")\n    requires_perm = models.ForeignKey(\n        \"core.Permission\", on_delete=models.CASCADE, null=True\n    )\n\n    target = models.CharField(\n        max_length=50,\n        default=\"route\",\n        choices=[\n            (\"route\", \"route\"),\n            (\"link\", \"link\"),\n            (\"link_blank\", \"link_blank\"),\n        ],\n    )\n    route = models.CharField(max_length=255, null=True)\n    link = models.URLField(null=True)\n\n    order = models.FloatField(default=1)\n    style = models.CharField(\n        max_length=50,\n        default=\"normal\",\n        choices=[\n            (\"normal\", \"normal\"),\n        ],\n    )\n\n    icon_name = models.CharField(max_length=255, null=True)\n    icon_path = models.URLField(null=True)\n\n    def __str__(self):\n        \"\"\"Return string representation of the model.\"\"\"\n        return f\"MenuItem ({self.name})\"\n\n    def get_menu(self, menu_name, extension_name=\"core\"):\n        \"\"\"Add this item to a menu.\"\"\"\n        extension = Extension.objects.get(name=extension_name)\n        menu = Menu.objects.get(name=menu_name, extension=extension)\n        return menu\n</code></pre>"},{"location":"extensions/payments/","title":"Payments","text":"<p>Manage payment methods, invoices, and subscriptions.</p> <p>At the moment, no payment provider is included in this extension. There is, however, a custom extension that connects invoices to the ERP System Lotzapp.</p>"},{"location":"extensions/payments/#installation","title":"Installation","text":"<p>Add <code>collectivo.payments</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/payments/#reference","title":"Reference","text":""},{"location":"extensions/payments/#collectivo.payments.models.PaymentProfile","title":"<code>PaymentProfile</code>","text":"<p>An profile of a user, defining payment methods.</p> Source code in <code>collectivo/payments/models.py</code> <pre><code>class PaymentProfile(models.Model):\n    \"\"\"An profile of a user, defining payment methods.\"\"\"\n\n    user = models.OneToOneField(\n        User,\n        primary_key=True,\n        on_delete=models.CASCADE,\n        related_name=\"payment_profile\",\n        help_text=\"The user that owns this profile.\",\n    )\n\n    payment_method = models.CharField(\n        choices=[\n            (\"transfer\", \"Transfer\"),\n            (\"sepa\", \"Direct debit\"),\n        ],\n        max_length=30,\n    )\n\n    bank_account_iban = models.CharField(max_length=255, null=True, blank=True)\n    bank_account_owner = models.CharField(\n        max_length=255, null=True, blank=True\n    )\n\n    history = HistoricalRecords()\n\n    def __str__(self):\n        \"\"\"Return a string representation of the object.\"\"\"\n        return f\"{self.user.first_name} {self.user.last_name}\"\n</code></pre>"},{"location":"extensions/payments/#collectivo.payments.models.Invoice","title":"<code>Invoice</code>","text":"<p>An invoice.</p> Source code in <code>collectivo/payments/models.py</code> <pre><code>class Invoice(models.Model):\n    \"\"\"An invoice.\"\"\"\n\n    payment_from = models.ForeignKey(\n        Account,\n        on_delete=models.PROTECT,\n        related_name=\"invoices_out\",\n        null=True,\n    )\n    payment_to = models.ForeignKey(\n        Account,\n        on_delete=models.PROTECT,\n        related_name=\"invoices_in\",\n        null=True,\n    )\n\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.SET_NULL,\n        null=True,\n        blank=True,\n    )\n\n    status = models.CharField(\n        max_length=10,\n        choices=[\n            (\"draft\", \"draft\"),\n            (\"open\", \"open\"),\n            (\"paid\", \"paid\"),\n            (\"canceled\", \"canceled\"),\n            (\"failure\", \"failure\"),\n        ],\n    )\n\n    date_created = models.DateField(default=datetime.date.today)\n    date_due = models.DateField(null=True, blank=True)\n    date_paid = models.DateField(null=True, blank=True)\n\n    subscription = models.ForeignKey(\n        \"Subscription\",\n        on_delete=models.PROTECT,\n        null=True,\n        blank=True,\n        related_name=\"invoices\",\n    )\n\n    notes = models.TextField(blank=True)\n\n    history = HistoricalRecords()\n\n    def __str__(self):\n        \"\"\"Return a string representation of the object.\"\"\"\n        return str(self.id)\n</code></pre>"},{"location":"extensions/payments/#collectivo.payments.models.Subscription","title":"<code>Subscription</code>","text":"<p>A subscription that creates automatic invoices.</p> Source code in <code>collectivo/payments/models.py</code> <pre><code>class Subscription(models.Model):\n    \"\"\"A subscription that creates automatic invoices.\"\"\"\n\n    payment_from = models.ForeignKey(\n        Account,\n        on_delete=models.PROTECT,\n        related_name=\"subscriptions_out\",\n        null=True,\n    )\n    payment_to = models.ForeignKey(\n        Account,\n        on_delete=models.PROTECT,\n        related_name=\"subscriptions_in\",\n        null=True,\n    )\n\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        on_delete=models.SET_NULL,\n        null=True,\n        blank=True,\n    )\n\n    status = models.CharField(\n        max_length=10,\n        default=\"draft\",\n        choices=[\n            (\"draft\", \"draft\"),\n            (\"paused\", \"paused\"),\n            (\"active\", \"active\"),\n            (\"ended\", \"ended\"),\n        ],\n    )\n\n    date_started = models.DateField(default=datetime.date.today)\n    repeat_each = models.IntegerField(default=1)\n    repeat_unit = models.CharField(\n        max_length=10,\n        choices=[\n            (\"year\", \"year\"),\n            (\"month\", \"month\"),\n            (\"week\", \"week\"),\n            (\"day\", \"day\"),\n        ],\n    )\n\n    notes = models.TextField(blank=True)\n\n    history = HistoricalRecords()\n\n    def __str__(self):\n        \"\"\"Return a string representation of the object.\"\"\"\n        return self.name\n</code></pre>"},{"location":"extensions/profiles/","title":"Profiles","text":"<p>Create a user profile that users can manage by themselves.</p>"},{"location":"extensions/profiles/#installation","title":"Installation","text":"<p>Add <code>collectivo.profiles</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/profiles/#reference","title":"Reference","text":""},{"location":"extensions/profiles/#collectivo.profiles.models.UserProfile","title":"<code>UserProfile</code>","text":"<p>Extension of the user model with a user profile.</p> Source code in <code>collectivo/profiles/models.py</code> <pre><code>class UserProfile(models.Model):\n    \"\"\"Extension of the user model with a user profile.\"\"\"\n\n    # User account\n    user = models.OneToOneField(\n        get_user_model(),\n        primary_key=True,\n        on_delete=models.CASCADE,\n        related_name=\"profile\",\n    )\n\n    # Personal data\n    person_type = models.CharField(\n        max_length=50,\n        null=True,\n        choices=[\n            (\"natural\", \"natural\"),\n            (\"legal\", \"legal\"),\n        ],\n    )\n    gender = models.CharField(\n        max_length=50,\n        null=True,\n        choices=[\n            (\"diverse\", \"diverse\"),\n            (\"female\", \"female\"),\n            (\"male\", \"male\"),\n        ],\n    )\n    address_street = models.CharField(max_length=255)\n    address_number = models.CharField(max_length=255)\n    address_stair = models.CharField(max_length=255, blank=True)\n    address_door = models.CharField(max_length=255, blank=True)\n    address_postcode = models.CharField(max_length=255)\n    address_city = models.CharField(max_length=255)\n    address_country = models.CharField(max_length=255)\n    phone = models.CharField(max_length=255, blank=True)\n\n    # Personal data (only for natural person)\n    birthday = models.DateField(null=True, blank=True)\n    occupation = models.CharField(max_length=255, null=True, blank=True)\n\n    # Personal data (only for legal person)\n    legal_name = models.CharField(max_length=255, blank=True)\n    legal_type = models.CharField(max_length=255, blank=True)\n    legal_id = models.CharField(max_length=255, blank=True)\n\n    # Admin data\n    notes = models.TextField(blank=True)\n    history = HistoricalRecords()\n    is_registered = models.BooleanField(default=False)\n\n    def __str__(self):\n        \"\"\"Return string representation.\"\"\"\n        return f\"{self.user.first_name} {self.user.last_name}\"\n</code></pre>"},{"location":"extensions/shifts/","title":"Shifts","text":"<p>Under construction</p> <p>This extension is still under construction and is not yet ready for production.</p>"},{"location":"extensions/tags/","title":"Tags","text":"<p>Add tags to users. Tags can be used for any kind of clustering, filtering, or automation and can be used to describe internal processes of your organisation.</p>"},{"location":"extensions/tags/#installation","title":"Installation","text":"<p>Add <code>collectivo.tags</code> to <code>extensions</code> in <code>collectivo.yml</code>.</p>"},{"location":"extensions/tags/#reference","title":"Reference","text":""},{"location":"extensions/tags/#collectivo.tags.models.Tag","title":"<code>Tag</code>","text":"<p>A tag that can be assigned to users.</p> Source code in <code>collectivo/tags/models.py</code> <pre><code>class Tag(models.Model):\n    \"\"\"A tag that can be assigned to users.\"\"\"\n\n    name = models.CharField(max_length=255, unique=True)\n    description = models.TextField(blank=True)\n    parent = models.ForeignKey(\n        \"self\",\n        null=True,\n        blank=True,\n        on_delete=models.CASCADE,\n        related_name=\"children\",\n    )\n    users = models.ManyToManyField(\n        get_user_model(), related_name=\"tags\", blank=True\n    )\n    extension = models.ForeignKey(\n        \"extensions.Extension\",\n        null=True,\n        blank=True,\n        on_delete=models.CASCADE,\n        help_text=EXTENSION_HELP_TEXT,\n    )\n\n    history = HistoricalRecords()\n\n    def __str__(self):\n        \"\"\"Return string representation.\"\"\"\n        return self.name\n</code></pre>"}]}